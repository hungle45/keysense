---
phase: 03.1-polish
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hooks/useHitDetection.ts
  - src/types/pitch.ts
  - src/hooks/usePitchDetection.ts
autonomous: true
requirements: [GAME-04]

must_haves:
  truths:
    - "Hit detection only triggers on sustained (150ms) correct notes with strong input"
    - "No false positives from noise, coughs, or octave jump artifacts"
    - "Visual feedback shows green only on success, no red for glitches"
    - "Pitch detector exposes RMS and clarity values for hit detection"
  artifacts:
    - path: "src/hooks/useHitDetection.ts"
      provides: "Wait Mode hit detection with volume+clarity gates"
      contains: "rms"
    - path: "src/types/pitch.ts"
      provides: "Extended PitchResult with rms field"
      contains: "rms"
    - path: "src/hooks/usePitchDetection.ts"
      provides: "RMS included in pitch result"
      contains: "rms: currentRMS"
  key_links:
    - from: "src/hooks/usePitchDetection.ts"
      to: "src/hooks/useHitDetection.ts"
      via: "PitchResult.rms and PitchResult.clarity"
      pattern: "pitch\\.rms.*pitch\\.clarity"
    - from: "src/hooks/useHitDetection.ts"
      to: "src/screens/GameScreen.tsx"
      via: "onHit callback"
      pattern: "onHit"
---

<objective>
Implement Wait Mode hit detection with volume and clarity gates.

Purpose: Users need reliable hit detection that doesn't trigger on noise, coughs, or harmonic artifacts. Only sustained, confident input should count as a hit.
Output: Robust hit detection with Strong Input Gate (volume + clarity), 150ms sustain, and decay filtering.
</objective>

<execution_context>
@/Volumes/External/Users/my_mac/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Volumes/External/Users/my_mac/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03.1-polish/03.1-GOAL.md

<interfaces>
<!-- Key types and functions the executor needs -->

From src/types/pitch.ts (current):
```typescript
export interface PitchResult {
  frequency: number;
  note: string;
  octave: number;
  cents: number;
  clarity: number;
}
```

From src/hooks/usePitchDetection.ts:
```typescript
// Line 58: RMS is already calculated
const currentRMS = calculateRMS(dataArray);

// Line 73: clarity is already available from detector result
const { frequency, clarity } = result;
```

From src/hooks/useHitDetection.ts (current):
```typescript
const SUSTAIN_DURATION_MS = 200;  // Will change to 150

interface UseHitDetectionOptions {
  pitch: PitchResult | null;
  activeNotes: TargetNote[];
  scrollSpeed: ScrollSpeed;
  containerWidth: number;
  isRunning: boolean;
  onHit: (noteId: string, playedNote: string, playedOctave: number) => void;
}
```

Wait Mode Requirements (from user):
1. Strong Input Gate: volume/RMS > threshold AND clarity > threshold
2. Sustain: 150ms (reduced from 200ms)
3. Decay detection: Ignore octave jumps when volume is decreasing
4. Visual: Green on success only, no red for glitches
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend PitchResult to include RMS</name>
  <files>src/types/pitch.ts, src/hooks/usePitchDetection.ts</files>
  <action>
**In src/types/pitch.ts:**
Add `rms` field to PitchResult interface:

```typescript
export interface PitchResult {
  frequency: number;
  note: string;
  octave: number;
  cents: number;
  clarity: number;
  rms: number;  // ADD: Volume level for hit detection
}
```

**In src/hooks/usePitchDetection.ts:**
Pass the already-calculated `currentRMS` to the PitchResult.

Find the `setPitch()` call around line 77-83 and add the rms field:

```typescript
setPitch({
  frequency,
  note: noteResult.note,
  octave: noteResult.octave,
  cents,
  clarity,
  rms: currentRMS,  // ADD: Include RMS in result
});
```

This makes RMS available to downstream consumers (useHitDetection) without duplicating calculations.
  </action>
  <verify>
    <automated>npm run build && npm run lint</automated>
  </verify>
  <done>
- PitchResult type includes `rms: number` field
- usePitchDetection includes currentRMS in the pitch result
- Build passes (no type errors)
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Wait Mode hit detection</name>
  <files>src/hooks/useHitDetection.ts</files>
  <action>
Rewrite useHitDetection to implement Wait Mode with Strong Input Gate:

**1. Update constants:**
```typescript
// Sustain requirement reduced for better responsiveness
const SUSTAIN_DURATION_MS = 150;  // Changed from 200

// Strong Input Gate thresholds
const MIN_RMS_THRESHOLD = 0.01;       // Volume must be above this (roughly -40dB)
const MIN_CLARITY_THRESHOLD = 0.85;   // Clarity must be above this

// Decay detection: If RMS drops by this ratio, note is decaying
const DECAY_RATIO_THRESHOLD = 0.7;  // 30% drop indicates decay
```

**2. Update sustainedNoteRef to track volume:**
```typescript
const sustainedNoteRef = useRef<{
  noteId: string;
  startTime: number;
  note: string;
  octave: number;
  peakRMS: number;      // ADD: Track peak volume for decay detection
  lastRMS: number;      // ADD: Track last RMS for trend
} | null>(null);
```

**3. Add Strong Input Gate check function:**
```typescript
// Strong Input Gate: Both volume AND clarity must be above thresholds
const isStrongInput = useCallback((pitch: PitchResult): boolean => {
  return pitch.rms >= MIN_RMS_THRESHOLD && pitch.clarity >= MIN_CLARITY_THRESHOLD;
}, []);
```

**4. Add decay detection function:**
```typescript
// Detect if note is decaying (volume decreasing)
const isDecaying = useCallback((currentRMS: number, peakRMS: number): boolean => {
  return currentRMS < peakRMS * DECAY_RATIO_THRESHOLD;
}, []);
```

**5. Rewrite main detection effect:**
```typescript
useEffect(() => {
  if (!isRunning || !pitch) {
    sustainedNoteRef.current = null;
    return;
  }
  
  // Gate 1: Require strong input (volume + clarity)
  if (!isStrongInput(pitch)) {
    // Weak input - don't start or continue tracking
    // This filters out noise, coughs, background sounds
    sustainedNoteRef.current = null;
    return;
  }
  
  const matchingNote = findMatchingNote();
  const sustained = sustainedNoteRef.current;
  
  if (matchingNote) {
    if (sustained && sustained.noteId === matchingNote.id) {
      // Same note being played
      
      // Gate 2: Check for decay (octave jump artifact)
      // If volume is decreasing significantly, ignore (it's a harmonic artifact)
      if (isDecaying(pitch.rms, sustained.peakRMS)) {
        // Volume dropping - likely decay artifact, don't count as hit
        // But don't reset tracking - wait for strong input again
        return;
      }
      
      // Update peak RMS if current is higher
      if (pitch.rms > sustained.peakRMS) {
        sustained.peakRMS = pitch.rms;
      }
      sustained.lastRMS = pitch.rms;
      
      // Check sustain duration
      const sustainedDuration = Date.now() - sustained.startTime;
      if (sustainedDuration >= SUSTAIN_DURATION_MS) {
        // Success! Sustained correct note with strong input
        onHit(matchingNote.id, pitch.note, pitch.octave);
        sustainedNoteRef.current = null;
      }
    } else {
      // New matching note - start tracking
      sustainedNoteRef.current = {
        noteId: matchingNote.id,
        startTime: Date.now(),
        note: pitch.note,
        octave: pitch.octave,
        peakRMS: pitch.rms,
        lastRMS: pitch.rms,
      };
    }
  } else {
    // Wrong note or no note in window - reset
    // (Wrong notes are silent - no negative feedback)
    sustainedNoteRef.current = null;
  }
}, [pitch, isRunning, findMatchingNote, onHit, isStrongInput, isDecaying]);
```

**6. Optionally expose thresholds for debugging:**
```typescript
return {
  sustainedNote: sustainedNoteRef.current,
  hitWindowPixels: HIT_WINDOW_PIXELS,
  // Debug info
  thresholds: {
    rms: MIN_RMS_THRESHOLD,
    clarity: MIN_CLARITY_THRESHOLD,
    sustainMs: SUSTAIN_DURATION_MS,
  },
};
```
  </action>
  <verify>
    <automated>npm run build && npm run lint</automated>
  </verify>
  <done>
- Strong Input Gate implemented (volume AND clarity thresholds)
- Sustain duration reduced to 150ms
- Decay detection filters octave jump artifacts
- Wrong notes are silent (no negative feedback)
- TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 3: Update visual feedback (green only, no red glitches)</name>
  <files>src/components/game/ScrollingNote.tsx</files>
  <action>
The current ScrollingNote already has the correct visual feedback pattern:
- `bg-green-500` for hit notes
- `bg-red-400` for missed notes
- `bg-foreground` for pending notes

**Verify this is correct for Wait Mode:**

The "no red for glitches" requirement means:
- Red should ONLY show when a note scrolls past and is marked as 'missed'
- Red should NOT flash when wrong notes are played (already correct - wrong notes don't change status)
- Red should NOT appear during hit detection process

**Current code (line 75-79):**
```typescript
const noteColor = note.status === 'hit' 
  ? 'bg-green-500' 
  : note.status === 'missed' 
    ? 'bg-red-400' 
    : 'bg-foreground';
```

This is ALREADY correct for Wait Mode:
- `pending` → neutral (foreground)
- `hit` → green
- `missed` → red (only when note scrolls off without being hit)

**No changes needed to ScrollingNote.tsx** - the visual feedback logic is already Wait Mode compatible.

If you want to verify:
1. Confirm there's no other place setting status to 'missed' prematurely
2. Confirm useHitDetection doesn't set status (it only calls onHit for successful hits)
3. Confirm recordMiss is only called in GameScreen when note scrolls past

**Optional enhancement:** During hit tracking (sustained note is being held but not yet 150ms), you could add a subtle visual indicator like a pulse or glow. But this is not required for basic Wait Mode.
  </action>
  <verify>
    <automated>npm run build && npm run lint</automated>
  </verify>
  <done>
- Pending notes show neutral color (no visual feedback while waiting)
- Hit notes turn green only after successful 150ms sustain
- Missed notes turn red only after scrolling past
- No red flashes for wrong notes or glitches
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Build check:** `npm run build` succeeds
2. **Lint check:** `npm run lint` passes
3. **Manual testing of Wait Mode:**
   - Start a session and DON'T play anything — notes should pass without false hits
   - Make noise (tap mic, cough) — should NOT trigger hits
   - Play wrong note — should NOT trigger (no red flash either)
   - Play correct note briefly (<150ms) — should NOT trigger
   - Play correct note sustained (>150ms) with good volume — SHOULD turn green
   - Let note decay naturally — should NOT trigger octave jump hits
</verification>

<success_criteria>
1. PitchResult includes rms field
2. Strong Input Gate filters weak/noisy signals (volume + clarity thresholds)
3. 150ms sustain requirement for hits
4. Decay detection prevents octave jump artifacts from triggering
5. Visual feedback: neutral → green (hit) or red (missed/scrolled past)
6. No false positives from noise, coughs, or harmonics
7. Build and lint pass
</success_criteria>

<output>
After completion, create `.planning/phases/03.1-polish/03.1-02-SUMMARY.md`
</output>
