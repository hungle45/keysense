---
phase: 03-game-loop
plan: 02
type: execute
wave: 2
depends_on: [03-01]
files_modified:
  - src/components/game/SessionConfig.tsx
  - src/components/game/CountdownSplash.tsx
  - src/components/game/GrandStaff.tsx
  - src/components/game/TimingLine.tsx
  - src/components/game/ScrollingNote.tsx
  - src/screens/GameScreen.tsx
autonomous: true
requirements: [GAME-01, GAME-02, GAME-03, GAME-05, GAME-06]

must_haves:
  truths:
    - "User can select session duration (1min or 5min)"
    - "User can select hand position"
    - "User can select scroll speed (Slow/Medium/Fast)"
    - "3-2-1 countdown appears before session starts"
    - "Grand staff shows treble and bass clefs"
    - "Notes scroll from right to left"
    - "Timing line shows where notes should be played"
    - "Remaining time displays during session"
  artifacts:
    - path: "src/components/game/SessionConfig.tsx"
      provides: "Configuration form with duration, position, speed selectors"
      exports: ["SessionConfig"]
    - path: "src/components/game/CountdownSplash.tsx"
      provides: "3-2-1 countdown overlay"
      exports: ["CountdownSplash"]
    - path: "src/components/game/GrandStaff.tsx"
      provides: "Grand staff with treble and bass clefs"
      exports: ["GrandStaff"]
    - path: "src/components/game/ScrollingNote.tsx"
      provides: "Individual note that animates across staff"
      exports: ["ScrollingNote"]
    - path: "src/screens/GameScreen.tsx"
      provides: "Main game screen integrating all components"
      exports: ["GameScreen"]
  key_links:
    - from: "src/screens/GameScreen.tsx"
      to: "src/hooks/useGameSession.ts"
      via: "import hook"
      pattern: "useGameSession"
    - from: "src/components/game/ScrollingNote.tsx"
      to: "src/types/game.ts"
      via: "import TargetNote type"
      pattern: "import.*TargetNote"
---

<objective>
Create the visual game interface: session configuration, countdown splash, and scrolling grand staff visualization.

Purpose: Transform the game state machine into a visual rhythm game experience. Users select their preferences, see a countdown, then watch notes scroll across a grand staff toward a timing line.

Output: React components for config UI, countdown, grand staff, and scrolling notes
</objective>

<execution_context>
@/Volumes/External/Users/my_mac/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Volumes/External/Users/my_mac/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-game-loop/03-CONTEXT.md
@.planning/phases/03-game-loop/03-01-SUMMARY.md

<interfaces>
<!-- Types from Plan 01 that this plan consumes -->

From src/types/game.ts:
```typescript
export type HandPosition = 'middle-c' | 'g-position' | 'f-position';
export type ScrollSpeed = 'slow' | 'medium' | 'fast';
export type SessionDuration = '1min' | '5min';
export type GameStatus = 'idle' | 'countdown' | 'running' | 'complete';

export const SCROLL_SPEEDS: Record<ScrollSpeed, number>;
export const SESSION_DURATIONS: Record<SessionDuration, number>;

export interface GameConfig {
  duration: number;
  handPosition: HandPosition;
  scrollSpeed: ScrollSpeed;
}

export interface TargetNote {
  id: string;
  note: string;
  octave: number;
  spawnTime: number;
  hitTime: number | null;
  status: 'pending' | 'hit' | 'missed';
}

export interface GameState {
  status: GameStatus;
  config: GameConfig;
  countdownValue: number;
  activeNotes: TargetNote[];
  hits: number;
  misses: number;
}
```

From src/hooks/useGameSession.ts:
```typescript
export function useGameSession(): {
  state: GameState;
  remainingMs: number;
  accuracy: number;
  configure: (config: GameConfig) => void;
  startGame: () => void;
  spawnNote: () => void;
  recordHit: (noteId: string, playedNote: string, playedOctave: number) => void;
  recordMiss: (noteId: string) => void;
  reset: () => void;
}
```

From src/lib/game/notes.ts:
```typescript
export const HAND_POSITIONS: Record<HandPosition, { notes: string[]; baseOctave: number; clef: string }>;
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create session configuration and countdown components</name>
  <files>src/components/game/SessionConfig.tsx, src/components/game/CountdownSplash.tsx</files>
  <action>
Create SessionConfig.tsx - configuration form shown before session starts:

```tsx
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import type { GameConfig, HandPosition, ScrollSpeed } from '@/types/game';
import { SESSION_DURATIONS } from '@/types/game';

interface SessionConfigProps {
  config: GameConfig;
  onConfigChange: (config: GameConfig) => void;
  onStart: () => void;
}

export function SessionConfig({ config, onConfigChange, onStart }: SessionConfigProps) {
  const durations: Array<{ key: keyof typeof SESSION_DURATIONS; label: string }> = [
    { key: '1min', label: '1 Minute' },
    { key: '5min', label: '5 Minutes' },
  ];
  
  const positions: Array<{ value: HandPosition; label: string }> = [
    { value: 'middle-c', label: 'Middle C Position' },
    { value: 'g-position', label: 'G Position' },
    { value: 'f-position', label: 'F Position' },
  ];
  
  const speeds: Array<{ value: ScrollSpeed; label: string }> = [
    { value: 'slow', label: 'Slow' },
    { value: 'medium', label: 'Medium' },
    { value: 'fast', label: 'Fast' },
  ];
  
  return (
    <Card className="w-full max-w-md">
      <CardHeader>
        <CardTitle>Practice Session</CardTitle>
      </CardHeader>
      <CardContent className="space-y-6">
        {/* Duration selection */}
        <div className="space-y-2">
          <label className="text-sm font-medium">Duration</label>
          <div className="flex gap-2">
            {durations.map(({ key, label }) => (
              <Button
                key={key}
                variant={config.duration === SESSION_DURATIONS[key] ? 'default' : 'outline'}
                className="flex-1 min-h-[44px]"
                onClick={() => onConfigChange({ ...config, duration: SESSION_DURATIONS[key] })}
              >
                {label}
              </Button>
            ))}
          </div>
        </div>
        
        {/* Hand position selection */}
        <div className="space-y-2">
          <label className="text-sm font-medium">Hand Position</label>
          <div className="flex flex-col gap-2">
            {positions.map(({ value, label }) => (
              <Button
                key={value}
                variant={config.handPosition === value ? 'default' : 'outline'}
                className="min-h-[44px]"
                onClick={() => onConfigChange({ ...config, handPosition: value })}
              >
                {label}
              </Button>
            ))}
          </div>
        </div>
        
        {/* Speed selection */}
        <div className="space-y-2">
          <label className="text-sm font-medium">Scroll Speed</label>
          <div className="flex gap-2">
            {speeds.map(({ value, label }) => (
              <Button
                key={value}
                variant={config.scrollSpeed === value ? 'default' : 'outline'}
                className="flex-1 min-h-[44px]"
                onClick={() => onConfigChange({ ...config, scrollSpeed: value })}
              >
                {label}
              </Button>
            ))}
          </div>
        </div>
        
        <Button 
          className="w-full min-h-[44px] text-lg" 
          size="lg"
          onClick={onStart}
        >
          Start Practice
        </Button>
      </CardContent>
    </Card>
  );
}
```

Create CountdownSplash.tsx - full-screen countdown overlay:

```tsx
interface CountdownSplashProps {
  value: number;  // 3, 2, 1
}

export function CountdownSplash({ value }: CountdownSplashProps) {
  return (
    <div className="fixed inset-0 bg-background/95 flex items-center justify-center z-50">
      <div className="text-center">
        <div className="text-9xl font-bold animate-pulse">
          {value}
        </div>
        <p className="text-xl text-muted-foreground mt-4">
          Get ready...
        </p>
      </div>
    </div>
  );
}
```

Touch targets are 44px minimum per MOBILE-04. Duration selection supports both 1min (GAME-01) and 5min (GAME-02).
  </action>
  <verify>npx tsc --noEmit src/components/game/SessionConfig.tsx src/components/game/CountdownSplash.tsx</verify>
  <done>SessionConfig and CountdownSplash components exist with correct props and 44px touch targets</done>
</task>

<task type="auto">
  <name>Task 2: Create grand staff visualization components</name>
  <files>src/components/game/GrandStaff.tsx, src/components/game/TimingLine.tsx, src/components/game/ScrollingNote.tsx</files>
  <action>
Create GrandStaff.tsx - renders treble and bass clefs with staff lines:

```tsx
import { ReactNode } from 'react';

interface GrandStaffProps {
  children?: ReactNode;  // Notes will be rendered as children
  className?: string;
}

// Staff line spacing and positions
const STAFF_CONFIG = {
  lineSpacing: 10,       // pixels between staff lines
  staffHeight: 40,       // 4 spaces = 5 lines
  gap: 30,               // gap between treble and bass staff
  timingLinePosition: 80, // pixels from left edge where timing line is
};

export function GrandStaff({ children, className }: GrandStaffProps) {
  // Render 5 horizontal lines for a staff
  const renderStaffLines = (yOffset: number) => (
    <>
      {[0, 1, 2, 3, 4].map(line => (
        <line
          key={line}
          x1="0"
          x2="100%"
          y1={yOffset + line * STAFF_CONFIG.lineSpacing}
          y2={yOffset + line * STAFF_CONFIG.lineSpacing}
          stroke="currentColor"
          strokeWidth="1"
          className="text-border"
        />
      ))}
    </>
  );

  const totalHeight = STAFF_CONFIG.staffHeight * 2 + STAFF_CONFIG.gap + 40; // Extra padding

  return (
    <div className={`relative w-full overflow-hidden ${className}`} style={{ height: totalHeight }}>
      <svg className="absolute inset-0 w-full h-full">
        {/* Treble staff (top) */}
        <g className="treble-staff">
          <text x="10" y="35" className="text-2xl fill-foreground">ùÑû</text>
          {renderStaffLines(20)}
        </g>
        
        {/* Bass staff (bottom) */}
        <g className="bass-staff">
          <text x="10" y={20 + STAFF_CONFIG.staffHeight + STAFF_CONFIG.gap + 15} className="text-2xl fill-foreground">ùÑ¢</text>
          {renderStaffLines(20 + STAFF_CONFIG.staffHeight + STAFF_CONFIG.gap)}
        </g>
        
        {/* Timing line (vertical line where notes should be played) */}
        <line
          x1={STAFF_CONFIG.timingLinePosition}
          x2={STAFF_CONFIG.timingLinePosition}
          y1="0"
          y2={totalHeight}
          stroke="hsl(var(--primary))"
          strokeWidth="3"
          className="timing-line"
        />
      </svg>
      
      {/* Notes layer - positioned above staff */}
      <div className="absolute inset-0 pointer-events-none">
        {children}
      </div>
    </div>
  );
}

export { STAFF_CONFIG };
```

Create TimingLine.tsx - visual indicator for where to play (kept simple, already in GrandStaff):

```tsx
// TimingLine is integrated into GrandStaff.tsx as an SVG element
// This file exports utility functions for timing calculations

import { SCROLL_SPEEDS, type ScrollSpeed } from '@/types/game';

// Calculate how long a note takes to scroll from spawn to timing line
export function getScrollDuration(scrollSpeed: ScrollSpeed, distance: number): number {
  const pixelsPerSecond = SCROLL_SPEEDS[scrollSpeed];
  return (distance / pixelsPerSecond) * 1000; // ms
}

// Calculate note X position based on time since spawn
export function getNotePosition(
  spawnTime: number,
  scrollSpeed: ScrollSpeed,
  containerWidth: number,
  timingLineX: number
): number {
  const elapsed = Date.now() - spawnTime;
  const pixelsPerMs = SCROLL_SPEEDS[scrollSpeed] / 1000;
  
  // Notes start at right edge and move left
  const startX = containerWidth;
  const currentX = startX - (elapsed * pixelsPerMs);
  
  return currentX;
}

export const TIMING_LINE_X = 80; // Match STAFF_CONFIG.timingLinePosition
```

Create ScrollingNote.tsx - individual note that animates:

```tsx
import { useEffect, useState } from 'react';
import { SCROLL_SPEEDS, type ScrollSpeed, type TargetNote } from '@/types/game';
import { TIMING_LINE_X } from './TimingLine';

interface ScrollingNoteProps {
  note: TargetNote;
  scrollSpeed: ScrollSpeed;
  containerWidth: number;
  onReachTimingLine?: () => void;
  onScrollPast?: () => void;
}

// Map note + octave to Y position on staff
function getNoteYPosition(note: string, octave: number): number {
  // Middle C (C4) is on a ledger line below treble staff
  // Each note step is half the line spacing
  const notePositions: Record<string, number> = {
    'C': 0, 'D': 1, 'E': 2, 'F': 3, 'G': 4, 'A': 5, 'B': 6,
  };
  
  const middleCY = 60; // Y position of middle C (ledger line)
  const stepSize = 5;  // pixels per note step
  
  const noteIndex = notePositions[note] ?? 0;
  const octaveOffset = (octave - 4) * 7; // 7 notes per octave
  
  return middleCY - (noteIndex + octaveOffset) * stepSize;
}

export function ScrollingNote({ 
  note, 
  scrollSpeed, 
  containerWidth,
  onReachTimingLine,
  onScrollPast,
}: ScrollingNoteProps) {
  const [xPosition, setXPosition] = useState(containerWidth);
  
  useEffect(() => {
    const pixelsPerMs = SCROLL_SPEEDS[scrollSpeed] / 1000;
    let animationFrame: number;
    let hasReachedLine = false;
    let hasScrolledPast = false;
    
    const animate = () => {
      const elapsed = Date.now() - note.spawnTime;
      const newX = containerWidth - (elapsed * pixelsPerMs);
      setXPosition(newX);
      
      // Check if reached timing line
      if (!hasReachedLine && newX <= TIMING_LINE_X + 10) {
        hasReachedLine = true;
        onReachTimingLine?.();
      }
      
      // Check if scrolled past (off left edge)
      if (!hasScrolledPast && newX < -30) {
        hasScrolledPast = true;
        onScrollPast?.();
      }
      
      if (!hasScrolledPast) {
        animationFrame = requestAnimationFrame(animate);
      }
    };
    
    animationFrame = requestAnimationFrame(animate);
    
    return () => cancelAnimationFrame(animationFrame);
  }, [note.spawnTime, scrollSpeed, containerWidth, onReachTimingLine, onScrollPast]);
  
  const yPosition = getNoteYPosition(note.note, note.octave);
  
  // Color based on note status
  const noteColor = note.status === 'hit' 
    ? 'bg-green-500' 
    : note.status === 'missed' 
      ? 'bg-red-400' 
      : 'bg-foreground';
  
  return (
    <div
      className={`absolute w-6 h-4 rounded-full ${noteColor} transition-colors`}
      style={{
        left: xPosition,
        top: yPosition,
        transform: 'translate(-50%, -50%)',
      }}
    >
      {/* Note name label (visible during development) */}
      <span className="absolute -top-5 left-1/2 -translate-x-1/2 text-xs text-muted-foreground">
        {note.note}{note.octave}
      </span>
    </div>
  );
}
```

Notes scroll from right to left (rhythm game style per user decision). Green highlight on hit (per user decision). Staff uses standard grand staff layout with treble and bass clefs.
  </action>
  <verify>npx tsc --noEmit src/components/game/GrandStaff.tsx src/components/game/TimingLine.tsx src/components/game/ScrollingNote.tsx</verify>
  <done>Grand staff renders with both clefs, notes scroll from right to left, timing line visible, note colors reflect hit/miss status</done>
</task>

<task type="auto">
  <name>Task 3: Create GameScreen and integrate components</name>
  <files>src/screens/GameScreen.tsx, src/App.tsx</files>
  <action>
Create src/screens/GameScreen.tsx - main game screen:

```tsx
import { useRef, useEffect, useCallback } from 'react';
import { useGameSession } from '@/hooks/useGameSession';
import { SessionConfig } from '@/components/game/SessionConfig';
import { CountdownSplash } from '@/components/game/CountdownSplash';
import { GrandStaff, STAFF_CONFIG } from '@/components/game/GrandStaff';
import { ScrollingNote } from '@/components/game/ScrollingNote';
import { SCROLL_SPEEDS } from '@/types/game';
import type { PitchResult } from '@/types/pitch';

interface GameScreenProps {
  pitch: PitchResult | null;
}

// Format milliseconds as mm:ss
function formatTime(ms: number): string {
  const totalSeconds = Math.max(0, Math.floor(ms / 1000));
  const minutes = Math.floor(totalSeconds / 60);
  const seconds = totalSeconds % 60;
  return `${minutes}:${seconds.toString().padStart(2, '0')}`;
}

export function GameScreen({ pitch }: GameScreenProps) {
  const containerRef = useRef<HTMLDivElement>(null);
  const {
    state,
    remainingMs,
    accuracy,
    configure,
    startGame,
    spawnNote,
    recordHit,
    recordMiss,
    reset,
  } = useGameSession();
  
  const containerWidth = containerRef.current?.offsetWidth ?? 800;
  
  // Spawn notes at regular intervals based on scroll speed
  useEffect(() => {
    if (state.status !== 'running') return;
    
    // Calculate spawn interval based on scroll speed
    // Spawn when previous note is ~1/3 across the screen
    const pixelsPerSecond = SCROLL_SPEEDS[state.config.scrollSpeed];
    const spawnIntervalMs = (containerWidth / 3) / pixelsPerSecond * 1000;
    
    // Spawn first note immediately
    if (state.activeNotes.length === 0) {
      spawnNote();
    }
    
    const interval = setInterval(() => {
      if (state.status === 'running') {
        spawnNote();
      }
    }, spawnIntervalMs);
    
    return () => clearInterval(interval);
  }, [state.status, state.config.scrollSpeed, containerWidth, spawnNote, state.activeNotes.length]);
  
  // Handle note reaching timing line (for hit detection)
  const handleNoteAtTimingLine = useCallback((noteId: string) => {
    // This is called when note reaches timing line
    // Hit detection happens in Plan 03
  }, []);
  
  // Handle note scrolling past (mark as missed)
  const handleNoteMissed = useCallback((noteId: string) => {
    recordMiss(noteId);
  }, [recordMiss]);
  
  // Render based on game status
  if (state.status === 'idle') {
    return (
      <div className="flex items-center justify-center p-4">
        <SessionConfig
          config={state.config}
          onConfigChange={configure}
          onStart={startGame}
        />
      </div>
    );
  }
  
  if (state.status === 'countdown') {
    return <CountdownSplash value={state.countdownValue} />;
  }
  
  if (state.status === 'complete') {
    // Results shown - detailed implementation in Plan 03
    return (
      <div className="flex items-center justify-center p-4">
        <div className="text-center space-y-4">
          <h2 className="text-3xl font-bold">Session Complete!</h2>
          <div className="text-6xl font-bold text-primary">{accuracy}%</div>
          <p className="text-muted-foreground">
            {state.hits} hits / {state.misses} misses
          </p>
          <button
            className="px-6 py-3 bg-primary text-primary-foreground rounded-lg min-h-[44px]"
            onClick={reset}
          >
            Play Again
          </button>
        </div>
      </div>
    );
  }
  
  // Running state - show game UI
  return (
    <div className="flex flex-col h-full" ref={containerRef}>
      {/* Timer display */}
      <div className="flex justify-between items-center p-4">
        <div className="text-2xl font-mono font-bold">
          {formatTime(remainingMs)}
        </div>
        <div className="text-sm text-muted-foreground">
          Hits: {state.hits}
        </div>
      </div>
      
      {/* Grand staff with scrolling notes */}
      <div className="flex-1 px-4">
        <GrandStaff>
          {state.activeNotes.map(note => (
            <ScrollingNote
              key={note.id}
              note={note}
              scrollSpeed={state.config.scrollSpeed}
              containerWidth={containerWidth}
              onReachTimingLine={() => handleNoteAtTimingLine(note.id)}
              onScrollPast={() => handleNoteMissed(note.id)}
            />
          ))}
        </GrandStaff>
      </div>
      
      {/* Current pitch display (helpful for user) */}
      {pitch && (
        <div className="text-center p-4 text-lg">
          Playing: <span className="font-bold">{pitch.note}{pitch.octave}</span>
        </div>
      )}
    </div>
  );
}
```

Update src/App.tsx to add Game screen navigation:

1. Add 'game' to Screen type: `type Screen = 'home' | 'settings' | 'game';`
2. Add Game navigation button in the nav bar
3. Import and render GameScreen when currentScreen === 'game'
4. Pass pitch prop to GameScreen

Add to nav section:
```tsx
<Button
  variant={currentScreen === 'game' ? 'secondary' : 'ghost'}
  className="flex-1 rounded-none min-h-[44px]"
  onClick={() => setCurrentScreen('game')}
>
  <Play className="mr-2 h-5 w-5" />
  Practice
</Button>
```

Import Play icon from lucide-react. GameScreen receives pitch from usePitchDetection.
  </action>
  <verify>npm run build</verify>
  <done>GameScreen shows config ‚Üí countdown ‚Üí running with timer and scrolling notes ‚Üí complete with score. Navigation added to App.tsx.</done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds without errors
2. Manual test flow:
   - Navigate to Practice screen
   - See SessionConfig with duration/position/speed options
   - Tap "Start Practice"
   - See 3-2-1 countdown overlay
   - See grand staff with notes scrolling
   - Timer counts down
   - At 0, see results screen with accuracy
   - "Play Again" returns to config
</verification>

<success_criteria>
- SessionConfig allows selecting 1min/5min duration (GAME-01, GAME-02)
- Hand position and scroll speed are configurable (GAME-06)
- 3-2-1 countdown displays before session (per user decision)
- Grand staff shows treble and bass clefs
- Notes scroll from right to left toward timing line (GAME-03)
- Timer displays remaining time (GAME-05)
- Results show accuracy percentage when complete
- All touch targets are 44px minimum
</success_criteria>

<output>
After completion, create `.planning/phases/03-game-loop/03-02-SUMMARY.md`
</output>
