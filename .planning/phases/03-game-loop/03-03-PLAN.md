---
phase: 03-game-loop
plan: 03
type: execute
wave: 3
depends_on: [03-02]
files_modified:
  - src/hooks/useHitDetection.ts
  - src/components/game/ResultsModal.tsx
  - src/screens/GameScreen.tsx
autonomous: false
requirements: [GAME-04, GAME-05, GAME-06]

must_haves:
  truths:
    - "Correct note + correct octave at timing line registers as hit"
    - "~200ms sustained detection required for hit"
    - "Wrong note is silent (no negative feedback during play)"
    - "Missed notes are counted when they scroll past"
    - "Results modal shows accuracy percentage and breakdown"
    - "Play Again returns to config, Back to Menu exits"
  artifacts:
    - path: "src/hooks/useHitDetection.ts"
      provides: "Hit detection logic comparing pitch to active notes"
      exports: ["useHitDetection"]
    - path: "src/components/game/ResultsModal.tsx"
      provides: "End-of-session results display"
      exports: ["ResultsModal"]
  key_links:
    - from: "src/hooks/useHitDetection.ts"
      to: "src/hooks/usePitchDetection.ts"
      via: "consumes pitch result"
      pattern: "PitchResult"
    - from: "src/screens/GameScreen.tsx"
      to: "src/hooks/useHitDetection.ts"
      via: "integrates hit detection"
      pattern: "useHitDetection"
---

<objective>
Complete the game loop with hit detection logic and polished results modal.

Purpose: Wire pitch detection to the game state machine so playing the correct note at the right time registers a hit. Provide clear session results with accuracy breakdown and replay options.

Output: Hit detection hook, results modal component, full game integration
</objective>

<execution_context>
@/Volumes/External/Users/my_mac/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Volumes/External/Users/my_mac/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-game-loop/03-CONTEXT.md
@.planning/phases/03-game-loop/03-01-SUMMARY.md
@.planning/phases/03-game-loop/03-02-SUMMARY.md

<interfaces>
<!-- Types and hooks from previous plans -->

From src/types/pitch.ts:
```typescript
export interface PitchResult {
  frequency: number;
  note: string;
  octave: number;
  cents: number;
  clarity: number;
}
```

From src/types/game.ts:
```typescript
export interface TargetNote {
  id: string;
  note: string;
  octave: number;
  spawnTime: number;
  hitTime: number | null;
  status: 'pending' | 'hit' | 'missed';
}

export interface NoteAttempt {
  targetNote: TargetNote;
  playedNote: string | null;
  playedOctave: number | null;
  wasHit: boolean;
  timestamp: number;
}

export interface GameState {
  status: 'idle' | 'countdown' | 'running' | 'complete';
  activeNotes: TargetNote[];
  noteHistory: NoteAttempt[];
  hits: number;
  misses: number;
}
```

From src/hooks/useGameSession.ts:
```typescript
export function useGameSession(): {
  state: GameState;
  remainingMs: number;
  accuracy: number;
  recordHit: (noteId: string, playedNote: string, playedOctave: number) => void;
  recordMiss: (noteId: string) => void;
  reset: () => void;
}
```

From src/components/game/TimingLine.ts:
```typescript
export const TIMING_LINE_X = 80;
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create hit detection hook</name>
  <files>src/hooks/useHitDetection.ts</files>
  <action>
Create useHitDetection hook that compares detected pitch to active notes near timing line:

```typescript
import { useEffect, useRef, useCallback } from 'react';
import type { PitchResult } from '@/types/pitch';
import type { TargetNote, ScrollSpeed } from '@/types/game';
import { SCROLL_SPEEDS } from '@/types/game';
import { TIMING_LINE_X } from '@/components/game/TimingLine';

interface UseHitDetectionOptions {
  pitch: PitchResult | null;
  activeNotes: TargetNote[];
  scrollSpeed: ScrollSpeed;
  containerWidth: number;
  isRunning: boolean;
  onHit: (noteId: string, playedNote: string, playedOctave: number) => void;
}

// Hit window: how close to timing line a note must be to count (pixels)
const HIT_WINDOW_PIXELS = 40;  // +/- 40 pixels from timing line

// Sustain requirement: how long correct note must be held (ms)
const SUSTAIN_DURATION_MS = 200;

export function useHitDetection({
  pitch,
  activeNotes,
  scrollSpeed,
  containerWidth,
  isRunning,
  onHit,
}: UseHitDetectionOptions) {
  // Track sustained note detection
  const sustainedNoteRef = useRef<{
    noteId: string;
    startTime: number;
    note: string;
    octave: number;
  } | null>(null);
  
  // Calculate current X position of a note
  const getNoteX = useCallback((note: TargetNote): number => {
    const elapsed = Date.now() - note.spawnTime;
    const pixelsPerMs = SCROLL_SPEEDS[scrollSpeed] / 1000;
    return containerWidth - (elapsed * pixelsPerMs);
  }, [scrollSpeed, containerWidth]);
  
  // Check if note is within hit window
  const isInHitWindow = useCallback((noteX: number): boolean => {
    return Math.abs(noteX - TIMING_LINE_X) <= HIT_WINDOW_PIXELS;
  }, []);
  
  // Find the note in hit window that matches the played pitch
  const findMatchingNote = useCallback((): TargetNote | null => {
    if (!pitch) return null;
    
    for (const note of activeNotes) {
      if (note.status !== 'pending') continue;
      
      const noteX = getNoteX(note);
      if (!isInHitWindow(noteX)) continue;
      
      // Exact match required: same note AND same octave (per user decision)
      if (note.note === pitch.note && note.octave === pitch.octave) {
        return note;
      }
    }
    
    return null;
  }, [pitch, activeNotes, getNoteX, isInHitWindow]);
  
  // Main detection effect
  useEffect(() => {
    if (!isRunning || !pitch) {
      // Reset sustained tracking when not running or no pitch
      sustainedNoteRef.current = null;
      return;
    }
    
    const matchingNote = findMatchingNote();
    
    if (matchingNote) {
      const sustained = sustainedNoteRef.current;
      
      if (sustained && sustained.noteId === matchingNote.id) {
        // Same note still being played - check if sustained long enough
        const sustainedDuration = Date.now() - sustained.startTime;
        
        if (sustainedDuration >= SUSTAIN_DURATION_MS) {
          // Hit! Note was sustained for required duration
          onHit(matchingNote.id, pitch.note, pitch.octave);
          sustainedNoteRef.current = null;  // Reset for next note
        }
        // Otherwise keep tracking this note
      } else {
        // New matching note detected - start tracking
        sustainedNoteRef.current = {
          noteId: matchingNote.id,
          startTime: Date.now(),
          note: pitch.note,
          octave: pitch.octave,
        };
      }
    } else {
      // No matching note - reset sustained tracking
      // (Wrong note is silent - no negative feedback per user decision)
      sustainedNoteRef.current = null;
    }
  }, [pitch, isRunning, findMatchingNote, onHit]);
  
  return {
    // Expose for debugging/visualization if needed
    sustainedNote: sustainedNoteRef.current,
    hitWindowPixels: HIT_WINDOW_PIXELS,
  };
}
```

Key implementation details:
- Exact octave match required (C4 ≠ C3) per user decision
- ~200ms sustained hold required per user decision
- Wrong note is silent (no negative feedback) per user decision
- Hit window is configurable but defaults to 40px around timing line
  </action>
  <verify>npx tsc --noEmit src/hooks/useHitDetection.ts</verify>
  <done>useHitDetection hook exports and compiles, implements exact octave matching with 200ms sustain requirement</done>
</task>

<task type="auto">
  <name>Task 2: Create results modal component</name>
  <files>src/components/game/ResultsModal.tsx</files>
  <action>
Create polished results modal that appears at session end:

```tsx
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import type { NoteAttempt } from '@/types/game';

interface ResultsModalProps {
  hits: number;
  misses: number;
  accuracy: number;
  noteHistory: NoteAttempt[];
  onPlayAgain: () => void;
  onBackToMenu: () => void;
}

export function ResultsModal({
  hits,
  misses,
  accuracy,
  noteHistory,
  onPlayAgain,
  onBackToMenu,
}: ResultsModalProps) {
  const total = hits + misses;
  
  // Determine performance message
  const getMessage = () => {
    if (accuracy >= 90) return { text: 'Excellent!', color: 'text-green-500' };
    if (accuracy >= 70) return { text: 'Great job!', color: 'text-blue-500' };
    if (accuracy >= 50) return { text: 'Good effort!', color: 'text-yellow-500' };
    return { text: 'Keep practicing!', color: 'text-muted-foreground' };
  };
  
  const message = getMessage();
  
  return (
    <div className="fixed inset-0 bg-background/95 flex items-center justify-center z-50 p-4">
      <Card className="w-full max-w-md">
        <CardHeader className="text-center">
          <CardTitle className="text-2xl">Session Complete!</CardTitle>
          <p className={`text-xl font-medium ${message.color}`}>{message.text}</p>
        </CardHeader>
        <CardContent className="space-y-6">
          {/* Main accuracy score */}
          <div className="text-center">
            <div className="text-7xl font-bold text-primary">
              {accuracy}%
            </div>
            <p className="text-muted-foreground mt-2">Accuracy</p>
          </div>
          
          {/* Stats breakdown */}
          <div className="grid grid-cols-3 gap-4 text-center">
            <div>
              <div className="text-2xl font-bold text-green-500">{hits}</div>
              <div className="text-sm text-muted-foreground">Hits</div>
            </div>
            <div>
              <div className="text-2xl font-bold text-red-400">{misses}</div>
              <div className="text-sm text-muted-foreground">Missed</div>
            </div>
            <div>
              <div className="text-2xl font-bold">{total}</div>
              <div className="text-sm text-muted-foreground">Total</div>
            </div>
          </div>
          
          {/* Progress bar visualization */}
          <div className="h-4 bg-muted rounded-full overflow-hidden">
            <div 
              className="h-full bg-green-500 transition-all"
              style={{ width: `${accuracy}%` }}
            />
          </div>
          
          {/* Action buttons */}
          <div className="flex gap-3">
            <Button
              variant="outline"
              className="flex-1 min-h-[44px]"
              onClick={onBackToMenu}
            >
              Back to Menu
            </Button>
            <Button
              className="flex-1 min-h-[44px]"
              onClick={onPlayAgain}
            >
              Play Again
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
```

Features per user decision:
- Modal overlay (not inline)
- Score shown prominently (accuracy percentage)
- Simple actions: "Play Again" and "Back to Menu" only
- 44px touch targets
- Encouraging messages (not punishing)
  </action>
  <verify>npx tsc --noEmit src/components/game/ResultsModal.tsx</verify>
  <done>ResultsModal displays accuracy, hits/misses breakdown, with Play Again and Back to Menu buttons</done>
</task>

<task type="auto">
  <name>Task 3: Integrate hit detection into GameScreen</name>
  <files>src/screens/GameScreen.tsx</files>
  <action>
Update GameScreen.tsx to integrate useHitDetection and ResultsModal:

1. Import useHitDetection hook and ResultsModal component
2. Add containerWidth state using useState + ResizeObserver or useRef with useEffect
3. Call useHitDetection with:
   - pitch prop
   - state.activeNotes
   - state.config.scrollSpeed
   - containerWidth
   - isRunning: state.status === 'running'
   - onHit: recordHit callback
4. Replace inline results UI with ResultsModal component
5. Add onBackToMenu handler that calls reset() and navigates to home

Update the complete state section:
```tsx
if (state.status === 'complete') {
  return (
    <ResultsModal
      hits={state.hits}
      misses={state.misses}
      accuracy={accuracy}
      noteHistory={state.noteHistory}
      onPlayAgain={reset}
      onBackToMenu={() => {
        reset();
        // Navigate to home - need to pass navigation callback
        onBackToMenu?.();
      }}
    />
  );
}
```

Add containerWidth tracking:
```tsx
const [containerWidth, setContainerWidth] = useState(800);

useEffect(() => {
  if (!containerRef.current) return;
  
  const observer = new ResizeObserver(entries => {
    const entry = entries[0];
    if (entry) {
      setContainerWidth(entry.contentRect.width);
    }
  });
  
  observer.observe(containerRef.current);
  return () => observer.disconnect();
}, []);
```

Add hit detection hook:
```tsx
useHitDetection({
  pitch,
  activeNotes: state.activeNotes,
  scrollSpeed: state.config.scrollSpeed,
  containerWidth,
  isRunning: state.status === 'running',
  onHit: recordHit,
});
```

Update GameScreenProps to include onBackToMenu:
```tsx
interface GameScreenProps {
  pitch: PitchResult | null;
  onBackToMenu?: () => void;
}
```

Update App.tsx to pass onBackToMenu that sets screen to 'home'.
  </action>
  <verify>npm run build</verify>
  <done>GameScreen fully integrates hit detection, shows ResultsModal on complete, Back to Menu navigates to home</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete game loop with:
- Session configuration (duration, hand position, speed)
- 3-2-1 countdown splash
- Scrolling grand staff with notes
- Hit detection (correct note + octave + 200ms sustain)
- Results modal with accuracy breakdown
  </what-built>
  <how-to-verify>
1. Open the app in browser (npm run dev)
2. Enable microphone on Home/Tuner screen
3. Navigate to "Practice" screen
4. Select 1-minute duration, Middle C position, Medium speed
5. Tap "Start Practice"
6. Verify: 3-2-1 countdown appears
7. Verify: Grand staff appears with notes scrolling right-to-left
8. Verify: Timer counts down from 1:00
9. Play correct notes on piano when they reach timing line
10. Verify: Hits register (green highlight, hit count increases)
11. Let some notes pass without playing
12. Wait for session to end (or let it run)
13. Verify: Results modal shows accuracy percentage
14. Tap "Play Again" - should return to config
15. Tap "Back to Menu" - should return to Tuner screen
  </how-to-verify>
  <resume-signal>Type "approved" if game loop works correctly, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
1. `npm run build` succeeds
2. Manual test: Complete game session flow from config to results
3. Hit detection: Playing correct note (exact pitch + octave) for ~200ms registers hit
4. Miss detection: Notes that scroll past without being hit are counted as misses
5. Wrong note: Playing wrong note has no effect (silent, per user decision)
6. Results: Shows accurate hit/miss counts and percentage
7. Navigation: Both "Play Again" and "Back to Menu" work correctly
</verification>

<success_criteria>
- Hit detection requires exact octave match (C4 ≠ C3) (GAME-04)
- ~200ms sustained correct note required for hit (per user decision)
- Wrong notes are silent - no negative feedback (per user decision)
- Results modal shows accuracy percentage (GAME-06)
- Results modal has "Play Again" and "Back to Menu" buttons only
- Complete session tracks all hits and misses (GAME-04)
- Session ends when timer reaches 0 (GAME-05)
</success_criteria>

<output>
After completion, create `.planning/phases/03-game-loop/03-03-SUMMARY.md`
</output>
