---
phase: 03-game-loop
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/game.ts
  - src/lib/game/notes.ts
  - src/hooks/useGameSession.ts
autonomous: true
requirements: [GAME-01, GAME-02, GAME-04, GAME-05]

must_haves:
  truths:
    - "Game session can be started with configurable duration"
    - "Session state transitions correctly: idle → countdown → running → complete"
    - "Random notes are generated within hand position range"
    - "Notes avoid consecutive duplicates"
    - "Remaining time computes correctly from startTime + duration - now"
  artifacts:
    - path: "src/types/game.ts"
      provides: "GameState, GameAction, NoteAttempt, HandPosition types"
      exports: ["GameState", "GameAction", "NoteAttempt", "HandPosition", "GameConfig", "ScrollSpeed"]
    - path: "src/lib/game/notes.ts"
      provides: "Note generation utilities"
      exports: ["generateRandomNote", "getNotesForPosition", "HAND_POSITIONS"]
    - path: "src/hooks/useGameSession.ts"
      provides: "Game session state machine"
      exports: ["useGameSession"]
  key_links:
    - from: "src/hooks/useGameSession.ts"
      to: "src/types/game.ts"
      via: "import types"
      pattern: "import.*from.*types/game"
    - from: "src/hooks/useGameSession.ts"
      to: "src/lib/game/notes.ts"
      via: "import note generation"
      pattern: "import.*from.*lib/game/notes"
---

<objective>
Create the core game loop foundation: type definitions, state machine, and note generation logic.

Purpose: Establish the typed contracts and state management that all game UI components will consume. This is the "brain" of the game - the logic layer that tracks session state, generates notes, and computes timing.

Output: TypeScript types, useReducer-based game session hook, note generation utilities
</objective>

<execution_context>
@/Volumes/External/Users/my_mac/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Volumes/External/Users/my_mac/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-game-loop/03-CONTEXT.md
@.planning/phases/03-game-loop/03-RESEARCH.md

<interfaces>
<!-- Key types from existing codebase that will be used -->

From src/types/pitch.ts:
```typescript
export interface PitchResult {
  frequency: number;
  note: string;
  octave: number;
  cents: number;
  clarity: number;
}
```

From src/lib/pitch/notes.ts:
```typescript
const NOTE_NAMES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

export interface NoteResult {
  note: string;
  octave: number;
  frequency: number;
}

export function frequencyToNote(frequency: number, a4?: number): NoteResult;
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create game type definitions</name>
  <files>src/types/game.ts</files>
  <action>
Create comprehensive type definitions for the game loop:

```typescript
// Hand positions determine note range
export type HandPosition = 
  | 'middle-c'      // C4-C5 (Middle C position)
  | 'g-position'    // G3-G4 (G below middle C)
  | 'f-position';   // F3-F4 (F below middle C)

export type ScrollSpeed = 'slow' | 'medium' | 'fast';

// Scroll speed in pixels per second (approximate)
export const SCROLL_SPEEDS: Record<ScrollSpeed, number> = {
  slow: 50,
  medium: 100,
  fast: 150,
};

// Session durations in milliseconds
export const SESSION_DURATIONS = {
  '1min': 60_000,
  '5min': 300_000,
} as const;

export type SessionDuration = keyof typeof SESSION_DURATIONS;

export interface GameConfig {
  duration: number;          // ms
  handPosition: HandPosition;
  scrollSpeed: ScrollSpeed;
}

// Target note on the scrolling staff
export interface TargetNote {
  id: string;               // Unique ID for React key
  note: string;             // C, D, E, F, G, A, B (natural notes only)
  octave: number;           // e.g., 4 for C4
  spawnTime: number;        // Timestamp when note was created
  hitTime: number | null;   // Timestamp when hit (null if not hit)
  status: 'pending' | 'hit' | 'missed';
}

// Record of each note attempt
export interface NoteAttempt {
  targetNote: TargetNote;
  playedNote: string | null;    // What user played (null if missed)
  playedOctave: number | null;
  wasHit: boolean;
  timestamp: number;
}

export type GameStatus = 'idle' | 'countdown' | 'running' | 'complete';

export interface GameState {
  status: GameStatus;
  config: GameConfig;
  startTime: number | null;     // When running phase started
  countdownValue: number;       // 3, 2, 1, 0
  activeNotes: TargetNote[];    // Notes currently on screen
  noteHistory: NoteAttempt[];   // All completed attempts
  hits: number;
  misses: number;
}

export type GameAction =
  | { type: 'CONFIGURE'; config: GameConfig }
  | { type: 'START_COUNTDOWN' }
  | { type: 'COUNTDOWN_TICK' }
  | { type: 'START_SESSION' }
  | { type: 'SPAWN_NOTE'; note: TargetNote }
  | { type: 'NOTE_HIT'; noteId: string; playedNote: string; playedOctave: number }
  | { type: 'NOTE_MISSED'; noteId: string }
  | { type: 'END_SESSION' }
  | { type: 'RESET' };
```

Use discriminated union pattern from RESEARCH.md. Include JSDoc comments on each type explaining purpose.
  </action>
  <verify>npx tsc --noEmit src/types/game.ts</verify>
  <done>src/types/game.ts exists with all game types exported, TypeScript compiles without errors</done>
</task>

<task type="auto">
  <name>Task 2: Create note generation utilities</name>
  <files>src/lib/game/notes.ts</files>
  <action>
Create note generation logic with hand position support:

```typescript
// Natural notes only (no sharps/flats per user decision)
const NATURAL_NOTES = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];

// Hand positions map to note ranges
// Full octave per position (8 notes: C-D-E-F-G-A-B-C)
export const HAND_POSITIONS = {
  'middle-c': { 
    notes: NATURAL_NOTES, 
    baseOctave: 4,  // C4-B4 + C5
    clef: 'treble' as const 
  },
  'g-position': { 
    notes: NATURAL_NOTES, 
    baseOctave: 3,  // G3-F4 range  
    clef: 'both' as const 
  },
  'f-position': { 
    notes: NATURAL_NOTES, 
    baseOctave: 3,  // F3-E4 range
    clef: 'bass' as const 
  },
} as const;

export type HandPosition = keyof typeof HAND_POSITIONS;

// Get all possible notes for a hand position
export function getNotesForPosition(position: HandPosition): Array<{ note: string; octave: number }> {
  const config = HAND_POSITIONS[position];
  const result: Array<{ note: string; octave: number }> = [];
  
  // Generate full octave of notes
  for (const note of config.notes) {
    result.push({ note, octave: config.baseOctave });
  }
  // Add the octave note (e.g., C5 for middle-c position)
  result.push({ note: 'C', octave: config.baseOctave + 1 });
  
  return result;
}

// Generate random note avoiding consecutive duplicates
export function generateRandomNote(
  position: HandPosition,
  excludeNote?: { note: string; octave: number } | null
): { note: string; octave: number } {
  const possibleNotes = getNotesForPosition(position);
  
  // Filter out the excluded note if provided
  const available = excludeNote
    ? possibleNotes.filter(n => !(n.note === excludeNote.note && n.octave === excludeNote.octave))
    : possibleNotes;
  
  return available[Math.floor(Math.random() * available.length)];
}

// Create a unique ID for a target note
export function createNoteId(): string {
  return `note-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
}
```

Implements avoidance of consecutive duplicates per RESEARCH.md recommendation. Natural notes only per user decision (no sharps/flats).
  </action>
  <verify>npx tsc --noEmit src/lib/game/notes.ts</verify>
  <done>src/lib/game/notes.ts exports generateRandomNote, getNotesForPosition, HAND_POSITIONS, createNoteId</done>
</task>

<task type="auto">
  <name>Task 3: Create useGameSession hook</name>
  <files>src/hooks/useGameSession.ts</files>
  <action>
Create the main game session state machine using useReducer pattern from RESEARCH.md:

```typescript
import { useReducer, useCallback, useMemo } from 'react';
import { useInterval } from 'usehooks-ts';
import type { 
  GameState, 
  GameAction, 
  GameConfig, 
  TargetNote,
  GameStatus 
} from '@/types/game';
import { generateRandomNote, createNoteId } from '@/lib/game/notes';

const initialState: GameState = {
  status: 'idle',
  config: {
    duration: 60_000,
    handPosition: 'middle-c',
    scrollSpeed: 'medium',
  },
  startTime: null,
  countdownValue: 3,
  activeNotes: [],
  noteHistory: [],
  hits: 0,
  misses: 0,
};

function gameReducer(state: GameState, action: GameAction): GameState {
  switch (action.type) {
    case 'CONFIGURE':
      return { ...state, config: action.config };
      
    case 'START_COUNTDOWN':
      return { 
        ...state, 
        status: 'countdown', 
        countdownValue: 3,
        hits: 0,
        misses: 0,
        activeNotes: [],
        noteHistory: [],
      };
      
    case 'COUNTDOWN_TICK':
      return { 
        ...state, 
        countdownValue: Math.max(0, state.countdownValue - 1) 
      };
      
    case 'START_SESSION':
      return { 
        ...state, 
        status: 'running', 
        startTime: Date.now(),
        countdownValue: 0,
      };
      
    case 'SPAWN_NOTE':
      return {
        ...state,
        activeNotes: [...state.activeNotes, action.note],
      };
      
    case 'NOTE_HIT': {
      const noteIndex = state.activeNotes.findIndex(n => n.id === action.noteId);
      if (noteIndex === -1) return state;
      
      const hitNote = state.activeNotes[noteIndex];
      const updatedNote: TargetNote = {
        ...hitNote,
        status: 'hit',
        hitTime: Date.now(),
      };
      
      return {
        ...state,
        activeNotes: state.activeNotes.filter(n => n.id !== action.noteId),
        noteHistory: [...state.noteHistory, {
          targetNote: updatedNote,
          playedNote: action.playedNote,
          playedOctave: action.playedOctave,
          wasHit: true,
          timestamp: Date.now(),
        }],
        hits: state.hits + 1,
      };
    }
      
    case 'NOTE_MISSED': {
      const missedNote = state.activeNotes.find(n => n.id === action.noteId);
      if (!missedNote) return state;
      
      return {
        ...state,
        activeNotes: state.activeNotes.filter(n => n.id !== action.noteId),
        noteHistory: [...state.noteHistory, {
          targetNote: { ...missedNote, status: 'missed' },
          playedNote: null,
          playedOctave: null,
          wasHit: false,
          timestamp: Date.now(),
        }],
        misses: state.misses + 1,
      };
    }
      
    case 'END_SESSION':
      // Mark all remaining active notes as missed
      const remainingMisses = state.activeNotes.map(note => ({
        targetNote: { ...note, status: 'missed' as const },
        playedNote: null,
        playedOctave: null,
        wasHit: false,
        timestamp: Date.now(),
      }));
      
      return {
        ...state,
        status: 'complete',
        activeNotes: [],
        noteHistory: [...state.noteHistory, ...remainingMisses],
        misses: state.misses + remainingMisses.length,
      };
      
    case 'RESET':
      return initialState;
      
    default:
      return state;
  }
}

export function useGameSession() {
  const [state, dispatch] = useReducer(gameReducer, initialState);
  
  // Compute remaining time (don't store in state - compute from timestamps)
  const remainingMs = useMemo(() => {
    if (state.status !== 'running' || !state.startTime) {
      return state.config.duration;
    }
    return Math.max(0, state.startTime + state.config.duration - Date.now());
  }, [state.status, state.startTime, state.config.duration]);
  
  // Compute accuracy percentage
  const accuracy = useMemo(() => {
    const total = state.hits + state.misses;
    if (total === 0) return 0;
    return Math.round((state.hits / total) * 100);
  }, [state.hits, state.misses]);
  
  // Countdown timer (1 second intervals)
  useInterval(
    () => {
      if (state.countdownValue > 1) {
        dispatch({ type: 'COUNTDOWN_TICK' });
      } else {
        dispatch({ type: 'START_SESSION' });
      }
    },
    state.status === 'countdown' ? 1000 : null
  );
  
  // Session timer (check every 100ms for end condition)
  useInterval(
    () => {
      if (remainingMs <= 0) {
        dispatch({ type: 'END_SESSION' });
      }
    },
    state.status === 'running' ? 100 : null
  );
  
  // Actions
  const configure = useCallback((config: GameConfig) => {
    dispatch({ type: 'CONFIGURE', config });
  }, []);
  
  const startGame = useCallback(() => {
    dispatch({ type: 'START_COUNTDOWN' });
  }, []);
  
  const spawnNote = useCallback(() => {
    const lastNote = state.activeNotes[state.activeNotes.length - 1];
    const excludeNote = lastNote ? { note: lastNote.note, octave: lastNote.octave } : null;
    const newNote = generateRandomNote(state.config.handPosition, excludeNote);
    
    const targetNote: TargetNote = {
      id: createNoteId(),
      note: newNote.note,
      octave: newNote.octave,
      spawnTime: Date.now(),
      hitTime: null,
      status: 'pending',
    };
    
    dispatch({ type: 'SPAWN_NOTE', note: targetNote });
  }, [state.activeNotes, state.config.handPosition]);
  
  const recordHit = useCallback((noteId: string, playedNote: string, playedOctave: number) => {
    dispatch({ type: 'NOTE_HIT', noteId, playedNote, playedOctave });
  }, []);
  
  const recordMiss = useCallback((noteId: string) => {
    dispatch({ type: 'NOTE_MISSED', noteId });
  }, []);
  
  const reset = useCallback(() => {
    dispatch({ type: 'RESET' });
  }, []);
  
  return {
    state,
    remainingMs,
    accuracy,
    configure,
    startGame,
    spawnNote,
    recordHit,
    recordMiss,
    reset,
  };
}
```

Uses useReducer pattern with discriminated unions as recommended in RESEARCH.md. Computes remainingMs from timestamps (not stored in state) to avoid drift issues. Uses useInterval from usehooks-ts (install if needed).
  </action>
  <verify>npm install usehooks-ts && npx tsc --noEmit src/hooks/useGameSession.ts</verify>
  <done>src/hooks/useGameSession.ts exports useGameSession hook with full state machine, countdown timer, and computed remainingMs</done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds without TypeScript errors
2. All three files exist with correct exports:
   - `src/types/game.ts` - GameState, GameAction, etc.
   - `src/lib/game/notes.ts` - generateRandomNote, getNotesForPosition
   - `src/hooks/useGameSession.ts` - useGameSession
3. `usehooks-ts` is installed in package.json
</verification>

<success_criteria>
- GameState type includes status discriminated union (idle/countdown/running/complete)
- useGameSession hook provides configure, startGame, spawnNote, recordHit, recordMiss, reset actions
- remainingMs is computed from timestamps, not stored in state
- Note generation avoids consecutive duplicates
- Countdown timer decrements 3-2-1 then transitions to running
- Session ends automatically when remainingMs reaches 0
</success_criteria>

<output>
After completion, create `.planning/phases/03-game-loop/03-01-SUMMARY.md`
</output>
